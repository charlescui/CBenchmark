// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `OpenIMWebService.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#include <OpenIMWebService.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __OpenImWebService__OpenImSrvMgr__BindService_name = "BindService";

static const ::std::string __OpenImWebService__OpenImSrvMgr__UnbindService_name = "UnbindService";

static const ::std::string __OpenImWebService__OpenImSrvMgr__DoAuth_name = "DoAuth";

static const ::std::string __OpenImWebService__OpenImSrvMgr__AddWebsite_name = "AddWebsite";

static const ::std::string __OpenImWebService__OpenImSrvMgr__DelWebsite_name = "DelWebsite";

static const ::std::string __OpenImWebService__OpenImSrvMgr__ChgWebsite_name = "ChgWebsite";

static const ::std::string __OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name = "ChgWebsiteStatus";

static const ::std::string __OpenImWebService__OpenImSrvMgr__SyncWebTribe_name = "SyncWebTribe";

static const ::std::string __OpenImWebService__OpenImSrvMgr__StopWebTribe_name = "StopWebTribe";

static const ::std::string __OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name = "ModifyWebTribe";

static const ::std::string __OpenImWebService__OpenImSrvMgr__AddTribeMember_name = "AddTribeMember";

static const ::std::string __OpenImWebService__OpenImSrvMgr__DelTribeMember_name = "DelTribeMember";

static const ::std::string __OpenImWebService__OpenImSrvMgr__QuitTribe_name = "QuitTribe";

static const ::std::string __OpenImWebService__OpenImSrvMgr__AddContact_name = "AddContact";

static const ::std::string __OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name = "SendWebsiteMsg";

static const ::std::string __OpenImWebService__OpenImSrvMgr__SendUserMsg_name = "SendUserMsg";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetHisOnline_name = "GetHisOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name = "GetAllHisOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetCurrOnline_name = "GetCurrOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name = "GetAllCurrOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name = "GetHisMaxOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name = "GetAllHisMaxOnline";

static const ::std::string __OpenImWebService__OpenImSrvMgr__QueryLog_name = "QueryLog";

::Ice::Object* IceInternal::upCast(::OpenImWebService::OpenImSrvMgr* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::OpenImWebService::OpenImSrvMgr* p) { return p; }

void
OpenImWebService::__read(::IceInternal::BasicStream* __is, ::OpenImWebService::OpenImSrvMgrPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::OpenImWebService::OpenImSrvMgr;
        v->__copyFrom(proxy);
    }
}

void
OpenImWebService::__writeKVMap(::IceInternal::BasicStream* __os, const ::OpenImWebService::KVMap& v)
{
    __os->writeSize(::Ice::Int(v.size()));
    ::OpenImWebService::KVMap::const_iterator p;
    for(p = v.begin(); p != v.end(); ++p)
    {
        __os->write(p->first);
        __os->write(p->second);
    }
}

void
OpenImWebService::__readKVMap(::IceInternal::BasicStream* __is, ::OpenImWebService::KVMap& v)
{
    ::Ice::Int sz;
    __is->readSize(sz);
    while(sz--)
    {
        ::std::pair<const  ::std::string, ::std::string> pair;
        __is->read(const_cast< ::std::string&>(pair.first));
        ::OpenImWebService::KVMap::iterator __i = v.insert(v.end(), pair);
        __is->read(__i->second);
    }
}

void
OpenImWebService::SWebUserInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(wangwangId);
    __os->write(webUid);
}

void
OpenImWebService::SWebUserInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(wangwangId);
    __is->read(webUid);
}

void
OpenImWebService::__writeSWebUserInfoSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SWebUserInfo* begin, const ::OpenImWebService::SWebUserInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSWebUserInfoSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SWebUserInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(2, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SMemberInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(webUid);
    __os->write(nickName);
    __os->write(tribeLevel);
}

void
OpenImWebService::SMemberInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(webUid);
    __is->read(nickName);
    __is->read(tribeLevel);
}

void
OpenImWebService::__writeSMemberInfoSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SMemberInfo* begin, const ::OpenImWebService::SMemberInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSMemberInfoSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SMemberInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(6, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::STribeInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(tribeId);
    __os->write(name);
    __os->write(icon);
    __os->write(description);
    __os->write(bulletin);
    __os->write(type);
    __os->write(masterId);
    if(memberList.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::OpenImWebService::__writeSWebUserInfoSeq(__os, &memberList[0], &memberList[0] + memberList.size());
    }
}

void
OpenImWebService::STribeInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(tribeId);
    __is->read(name);
    __is->read(icon);
    __is->read(description);
    __is->read(bulletin);
    __is->read(type);
    __is->read(masterId);
    ::OpenImWebService::__readSWebUserInfoSeq(__is, memberList);
}

void
OpenImWebService::__writeSTribeInfoSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::STribeInfo* begin, const ::OpenImWebService::STribeInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSTribeInfoSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::STribeInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(11, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SNotifySysMsg::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(createId);
    __os->write(cmdId);
    __os->write(style);
    __os->write(message);
    __os->write(saveFlag);
    __os->write(expireTime);
}

void
OpenImWebService::SNotifySysMsg::__read(::IceInternal::BasicStream* __is)
{
    __is->read(createId);
    __is->read(cmdId);
    __is->read(style);
    __is->read(message);
    __is->read(saveFlag);
    __is->read(expireTime);
}

void
OpenImWebService::__writeSNotifySysMsgSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SNotifySysMsg* begin, const ::OpenImWebService::SNotifySysMsg* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSNotifySysMsgSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SNotifySysMsgSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(12, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SWebStatistics::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(date);
    __os->write(maxOnline);
    __os->write(loginNum);
}

void
OpenImWebService::SWebStatistics::__read(::IceInternal::BasicStream* __is)
{
    __is->read(date);
    __is->read(maxOnline);
    __is->read(loginNum);
}

void
OpenImWebService::__writeSWebStatisticsSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SWebStatistics* begin, const ::OpenImWebService::SWebStatistics* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSWebStatisticsSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SWebStatisticsSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(9, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SWebStatisticsAll::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(serviceId);
    __os->write(webId);
    if(statList.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::OpenImWebService::__writeSWebStatisticsSeq(__os, &statList[0], &statList[0] + statList.size());
    }
}

void
OpenImWebService::SWebStatisticsAll::__read(::IceInternal::BasicStream* __is)
{
    __is->read(serviceId);
    __is->read(webId);
    ::OpenImWebService::__readSWebStatisticsSeq(__is, statList);
}

void
OpenImWebService::__writeSWebStatisticsAllSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SWebStatisticsAll* begin, const ::OpenImWebService::SWebStatisticsAll* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSWebStatisticsAllSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SWebStatisticsAllSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(3, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SWebOnlineStatisticsAll::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(serviceId);
    __os->write(webId);
    __os->write(maxOnline);
}

void
OpenImWebService::SWebOnlineStatisticsAll::__read(::IceInternal::BasicStream* __is)
{
    __is->read(serviceId);
    __is->read(webId);
    __is->read(maxOnline);
}

void
OpenImWebService::__writeSWebOnlineStatisticsAllSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SWebOnlineStatisticsAll* begin, const ::OpenImWebService::SWebOnlineStatisticsAll* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSWebOnlineStatisticsAllSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SWebOnlineStatisticsAllSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(6, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::SUrlInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(baseUrl);
    __os->write(trustUrl);
}

void
OpenImWebService::SUrlInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(baseUrl);
    __is->read(trustUrl);
}

void
OpenImWebService::__writeSUrlInfoSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SUrlInfo* begin, const ::OpenImWebService::SUrlInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSUrlInfoSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SUrlInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(2, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
OpenImWebService::QueryItems::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(actor);
    __os->write(password);
    __os->write(fromUid);
    __os->write(tribeId);
    __os->write(startDate);
    __os->write(endDate);
    __os->write(content);
    __os->write(startRow);
    __os->write(endRow);
}

void
OpenImWebService::QueryItems::__read(::IceInternal::BasicStream* __is)
{
    __is->read(actor);
    __is->read(password);
    __is->read(fromUid);
    __is->read(tribeId);
    __is->read(startDate);
    __is->read(endDate);
    __is->read(content);
    __is->read(startRow);
    __is->read(endRow);
}

void
OpenImWebService::SUidPairMsg::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(fromid);
    __os->write(msgTime);
    __os->write(msgcontent);
}

void
OpenImWebService::SUidPairMsg::__read(::IceInternal::BasicStream* __is)
{
    __is->read(fromid);
    __is->read(msgTime);
    __is->read(msgcontent);
}

void
OpenImWebService::__writeSUidPairMsgSeq(::IceInternal::BasicStream* __os, const ::OpenImWebService::SUidPairMsg* begin, const ::OpenImWebService::SUidPairMsg* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
OpenImWebService::__readSUidPairMsgSeq(::IceInternal::BasicStream* __is, ::OpenImWebService::SUidPairMsgSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(6, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::BindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& aliuid, const ::std::string& currToken, ::Ice::Long t, const ::std::string& wangwangId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__BindService_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->BindService(serviceId, webId, webUid, aliuid, currToken, t, wangwangId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_BindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& aliuid, const ::std::string& currToken, ::Ice::Long t, const ::std::string& wangwangId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__BindService_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__BindService_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__BindService_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(webUid);
        __os->write(aliuid);
        __os->write(currToken);
        __os->write(t);
        __os->write(wangwangId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_BindService(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__BindService_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::UnbindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& wangwangId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__UnbindService_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->UnbindService(serviceId, webId, webUid, wangwangId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_UnbindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& wangwangId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__UnbindService_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__UnbindService_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__UnbindService_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(webUid);
        __os->write(wangwangId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_UnbindService(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__UnbindService_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::DoAuth(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& aliuid, const ::std::string& token, ::Ice::Long t, ::std::string& webUid, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__DoAuth_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->DoAuth(serviceId, webId, aliuid, token, t, webUid, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_DoAuth(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& aliuid, const ::std::string& token, ::Ice::Long t, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__DoAuth_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__DoAuth_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__DoAuth_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(aliuid);
        __os->write(token);
        __os->write(t);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_DoAuth(::std::string& webUid, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__DoAuth_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(webUid);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::AddWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddWebsite_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->AddWebsite(serviceId, webId, name, webUrl, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_AddWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddWebsite_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__AddWebsite_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__AddWebsite_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(name);
        if(webUrl.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSUrlInfoSeq(__os, &webUrl[0], &webUrl[0] + webUrl.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_AddWebsite(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__AddWebsite_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::DelWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__DelWebsite_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->DelWebsite(serviceId, webId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_DelWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__DelWebsite_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__DelWebsite_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__DelWebsite_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_DelWebsite(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__DelWebsite_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::ChgWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__ChgWebsite_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->ChgWebsite(serviceId, webId, name, webUrl, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_ChgWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__ChgWebsite_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__ChgWebsite_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__ChgWebsite_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(name);
        if(webUrl.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSUrlInfoSeq(__os, &webUrl[0], &webUrl[0] + webUrl.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_ChgWebsite(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__ChgWebsite_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::ChgWebsiteStatus(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int status, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->ChgWebsiteStatus(serviceId, webId, status, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_ChgWebsiteStatus(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int status, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(status);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_ChgWebsiteStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::SyncWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::OpenImWebService::STribeInfo& tribe, ::Ice::Long& tribeId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__SyncWebTribe_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->SyncWebTribe(serviceId, webId, tribe, tribeId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_SyncWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::OpenImWebService::STribeInfo& tribe, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__SyncWebTribe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__SyncWebTribe_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__SyncWebTribe_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        tribe.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_SyncWebTribe(::Ice::Long& tribeId, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__SyncWebTribe_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(tribeId);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::StopWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__StopWebTribe_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->StopWebTribe(serviceId, webId, tribeId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_StopWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__StopWebTribe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__StopWebTribe_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__StopWebTribe_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_StopWebTribe(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__StopWebTribe_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::ModifyWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::KVMap& items, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->ModifyWebTribe(serviceId, webId, tribeId, items, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_ModifyWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::KVMap& items, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        ::OpenImWebService::__writeKVMap(__os, items);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_ModifyWebTribe(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::AddTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& member, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddTribeMember_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->AddTribeMember(serviceId, webId, tribeId, member, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_AddTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& member, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddTribeMember_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__AddTribeMember_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__AddTribeMember_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        member.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_AddTribeMember(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__AddTribeMember_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::DelTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::std::string& operId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__DelTribeMember_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->DelTribeMember(serviceId, webId, tribeId, memberId, operId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_DelTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::std::string& operId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__DelTribeMember_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__DelTribeMember_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__DelTribeMember_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        memberId.__write(__os);
        __os->write(operId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_DelTribeMember(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__DelTribeMember_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::QuitTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__QuitTribe_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->QuitTribe(serviceId, webId, tribeId, memberId, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_QuitTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__QuitTribe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__QuitTribe_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__QuitTribe_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        memberId.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_QuitTribe(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__QuitTribe_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::AddContact(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& wangwangId, const ::OpenImWebService::SWebUserInfoSeq& contactList, ::OpenImWebService::CntctSeq& cnt, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddContact_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->AddContact(serviceId, webId, wangwangId, contactList, cnt, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_AddContact(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& wangwangId, const ::OpenImWebService::SWebUserInfoSeq& contactList, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__AddContact_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__AddContact_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__AddContact_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(wangwangId);
        if(contactList.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSWebUserInfoSeq(__os, &contactList[0], &contactList[0] + contactList.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_AddContact(::OpenImWebService::CntctSeq& cnt, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__AddContact_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(cnt);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::SendWebsiteMsg(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::StringSeq& receivers, const ::OpenImWebService::SNotifySysMsg& message, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->SendWebsiteMsg(serviceId, webId, receivers, message, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_SendWebsiteMsg(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::StringSeq& receivers, const ::OpenImWebService::SNotifySysMsg& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        if(receivers.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&receivers[0], &receivers[0] + receivers.size());
        }
        message.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_SendWebsiteMsg(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::SendUserMsg(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int cmdId, const ::std::string& fromId, const ::std::string& toId, const ::OpenImWebService::KVMap& message, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__SendUserMsg_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->SendUserMsg(serviceId, webId, cmdId, fromId, toId, message, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_SendUserMsg(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int cmdId, const ::std::string& fromId, const ::std::string& toId, const ::OpenImWebService::KVMap& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__SendUserMsg_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__SendUserMsg_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__SendUserMsg_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(cmdId);
        __os->write(fromId);
        __os->write(toId);
        ::OpenImWebService::__writeKVMap(__os, message);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_SendUserMsg(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__SendUserMsg_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetHisOnline(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetHisOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetHisOnline(serviceId, webId, fromDate, toDate, data, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetHisOnline(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& fromDate, const ::std::string& toDate, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetHisOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetHisOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetHisOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(fromDate);
        __os->write(toDate);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetHisOnline(::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetHisOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::OpenImWebService::__readSWebStatisticsSeq(__is, data);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetAllHisOnline(const ::std::string& serviceId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetAllHisOnline(serviceId, fromDate, toDate, data, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetAllHisOnline(const ::std::string& serviceId, const ::std::string& fromDate, const ::std::string& toDate, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(fromDate);
        __os->write(toDate);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetAllHisOnline(::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::OpenImWebService::__readSWebStatisticsSeq(__is, data);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetCurrOnline(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Long& number, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetCurrOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetCurrOnline(serviceId, webId, number, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetCurrOnline(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetCurrOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetCurrOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetCurrOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetCurrOnline(::Ice::Long& number, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetCurrOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(number);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetAllCurrOnline(const ::std::string& serviceId, ::Ice::Long& number, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetAllCurrOnline(serviceId, number, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetAllCurrOnline(const ::std::string& serviceId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetAllCurrOnline(::Ice::Long& number, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(number);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetHisMaxOnline(const ::std::string& serviceId, const ::std::string& webId, ::OpenImWebService::SWebStatistics& data, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetHisMaxOnline(serviceId, webId, data, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetHisMaxOnline(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->write(webId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetHisMaxOnline(::OpenImWebService::SWebStatistics& data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    data.__read(__is);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::GetAllHisMaxOnline(const ::std::string& serviceId, ::std::string& date, ::Ice::Long& number, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->GetAllHisMaxOnline(serviceId, date, number, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_GetAllHisMaxOnline(const ::std::string& serviceId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(serviceId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_GetAllHisMaxOnline(::std::string& date, ::Ice::Long& number, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(date);
    __is->read(number);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::QueryLog(const ::OpenImWebService::QueryItems& qi, ::OpenImWebService::SUidPairMsgSeq& rl, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__OpenImWebService__OpenImSrvMgr__QueryLog_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::OpenImWebService::OpenImSrvMgr* __del = dynamic_cast< ::IceDelegate::OpenImWebService::OpenImSrvMgr*>(__delBase.get());
            return __del->QueryLog(qi, rl, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::OpenImWebService::OpenImSrvMgr::begin_QueryLog(const ::OpenImWebService::QueryItems& qi, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__OpenImWebService__OpenImSrvMgr__QueryLog_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __OpenImWebService__OpenImSrvMgr__QueryLog_name, __del, __cookie);
    try
    {
        __result->__prepare(__OpenImWebService__OpenImSrvMgr__QueryLog_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        qi.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::OpenImWebService::OpenImSrvMgr::end_QueryLog(::OpenImWebService::SUidPairMsgSeq& rl, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __OpenImWebService__OpenImSrvMgr__QueryLog_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::OpenImWebService::__readSUidPairMsgSeq(__is, rl);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::OpenImWebService::OpenImSrvMgr::ice_staticId()
{
    return ::OpenImWebService::OpenImSrvMgr::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::OpenImWebService::OpenImSrvMgr::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::OpenImWebService::OpenImSrvMgr);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::OpenImWebService::OpenImSrvMgr::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::OpenImWebService::OpenImSrvMgr);
}

::IceProxy::Ice::Object*
IceProxy::OpenImWebService::OpenImSrvMgr::__newInstance() const
{
    return new OpenImSrvMgr;
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::BindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& aliuid, const ::std::string& currToken, ::Ice::Long t, const ::std::string& wangwangId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__BindService_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(webUid);
        __os->write(aliuid);
        __os->write(currToken);
        __os->write(t);
        __os->write(wangwangId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::UnbindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& wangwangId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__UnbindService_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(webUid);
        __os->write(wangwangId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::DoAuth(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& aliuid, const ::std::string& token, ::Ice::Long t, ::std::string& webUid, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__DoAuth_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(aliuid);
        __os->write(token);
        __os->write(t);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(webUid);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::AddWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__AddWebsite_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(name);
        if(webUrl.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSUrlInfoSeq(__os, &webUrl[0], &webUrl[0] + webUrl.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::DelWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__DelWebsite_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::ChgWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__ChgWebsite_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(name);
        if(webUrl.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSUrlInfoSeq(__os, &webUrl[0], &webUrl[0] + webUrl.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::ChgWebsiteStatus(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int status, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(status);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::SyncWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::OpenImWebService::STribeInfo& tribe, ::Ice::Long& tribeId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__SyncWebTribe_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        tribe.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(tribeId);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::StopWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__StopWebTribe_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::ModifyWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::KVMap& items, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        ::OpenImWebService::__writeKVMap(__os, items);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::AddTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& member, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__AddTribeMember_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        member.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::DelTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::std::string& operId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__DelTribeMember_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        memberId.__write(__os);
        __os->write(operId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::QuitTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__QuitTribe_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(tribeId);
        memberId.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::AddContact(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& wangwangId, const ::OpenImWebService::SWebUserInfoSeq& contactList, ::OpenImWebService::CntctSeq& cnt, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__AddContact_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(wangwangId);
        if(contactList.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::OpenImWebService::__writeSWebUserInfoSeq(__os, &contactList[0], &contactList[0] + contactList.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(cnt);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::SendWebsiteMsg(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::StringSeq& receivers, const ::OpenImWebService::SNotifySysMsg& message, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        if(receivers.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&receivers[0], &receivers[0] + receivers.size());
        }
        message.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::SendUserMsg(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int cmdId, const ::std::string& fromId, const ::std::string& toId, const ::OpenImWebService::KVMap& message, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__SendUserMsg_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(cmdId);
        __os->write(fromId);
        __os->write(toId);
        ::OpenImWebService::__writeKVMap(__os, message);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetHisOnline(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetHisOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
        __os->write(fromDate);
        __os->write(toDate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::OpenImWebService::__readSWebStatisticsSeq(__is, data);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetAllHisOnline(const ::std::string& serviceId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(fromDate);
        __os->write(toDate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::OpenImWebService::__readSWebStatisticsSeq(__is, data);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetCurrOnline(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Long& number, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetCurrOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(number);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetAllCurrOnline(const ::std::string& serviceId, ::Ice::Long& number, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(number);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetHisMaxOnline(const ::std::string& serviceId, const ::std::string& webId, ::OpenImWebService::SWebStatistics& data, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
        __os->write(webId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        data.__read(__is);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::GetAllHisMaxOnline(const ::std::string& serviceId, ::std::string& date, ::Ice::Long& number, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(serviceId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(date);
        __is->read(number);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::OpenImWebService::OpenImSrvMgr::QueryLog(const ::OpenImWebService::QueryItems& qi, ::OpenImWebService::SUidPairMsgSeq& rl, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __OpenImWebService__OpenImSrvMgr__QueryLog_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        qi.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::OpenImWebService::__readSUidPairMsgSeq(__is, rl);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::BindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& aliuid, const ::std::string& currToken, ::Ice::Long t, const ::std::string& wangwangId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& aliuid, const ::std::string& currToken, ::Ice::Long t, const ::std::string& wangwangId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_webUid(webUid),
            _m_aliuid(aliuid),
            _m_currToken(currToken),
            _m_t(t),
            _m_wangwangId(wangwangId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->BindService(_m_serviceId, _m_webId, _m_webUid, _m_aliuid, _m_currToken, _m_t, _m_wangwangId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_webUid;
        const ::std::string& _m_aliuid;
        const ::std::string& _m_currToken;
        ::Ice::Long _m_t;
        const ::std::string& _m_wangwangId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__BindService_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, webUid, aliuid, currToken, t, wangwangId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::UnbindService(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& wangwangId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& webUid, const ::std::string& wangwangId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_webUid(webUid),
            _m_wangwangId(wangwangId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->UnbindService(_m_serviceId, _m_webId, _m_webUid, _m_wangwangId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_webUid;
        const ::std::string& _m_wangwangId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__UnbindService_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, webUid, wangwangId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::DoAuth(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& aliuid, const ::std::string& token, ::Ice::Long t, ::std::string& webUid, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& aliuid, const ::std::string& token, ::Ice::Long t, ::std::string& webUid, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_aliuid(aliuid),
            _m_token(token),
            _m_t(t),
            _m_webUid(webUid)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->DoAuth(_m_serviceId, _m_webId, _m_aliuid, _m_token, _m_t, _m_webUid, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_aliuid;
        const ::std::string& _m_token;
        ::Ice::Long _m_t;
        ::std::string& _m_webUid;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__DoAuth_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, aliuid, token, t, webUid, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::AddWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_name(name),
            _m_webUrl(webUrl)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->AddWebsite(_m_serviceId, _m_webId, _m_name, _m_webUrl, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_name;
        const ::OpenImWebService::SUrlInfoSeq& _m_webUrl;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__AddWebsite_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, name, webUrl, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::DelWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->DelWebsite(_m_serviceId, _m_webId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__DelWebsite_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::ChgWebsite(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& name, const ::OpenImWebService::SUrlInfoSeq& webUrl, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_name(name),
            _m_webUrl(webUrl)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->ChgWebsite(_m_serviceId, _m_webId, _m_name, _m_webUrl, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_name;
        const ::OpenImWebService::SUrlInfoSeq& _m_webUrl;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__ChgWebsite_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, name, webUrl, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::ChgWebsiteStatus(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int status, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int status, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_status(status)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->ChgWebsiteStatus(_m_serviceId, _m_webId, _m_status, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        ::Ice::Int _m_status;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__ChgWebsiteStatus_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, status, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::SyncWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::OpenImWebService::STribeInfo& tribe, ::Ice::Long& tribeId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::OpenImWebService::STribeInfo& tribe, ::Ice::Long& tribeId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribe(tribe),
            _m_tribeId(tribeId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->SyncWebTribe(_m_serviceId, _m_webId, _m_tribe, _m_tribeId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::OpenImWebService::STribeInfo& _m_tribe;
        ::Ice::Long& _m_tribeId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__SyncWebTribe_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribe, tribeId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::StopWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribeId(tribeId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->StopWebTribe(_m_serviceId, _m_webId, _m_tribeId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_tribeId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__StopWebTribe_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribeId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::ModifyWebTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::KVMap& items, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::KVMap& items, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribeId(tribeId),
            _m_items(items)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->ModifyWebTribe(_m_serviceId, _m_webId, _m_tribeId, _m_items, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_tribeId;
        const ::OpenImWebService::KVMap& _m_items;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__ModifyWebTribe_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribeId, items, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::AddTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& member, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& member, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribeId(tribeId),
            _m_member(member)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->AddTribeMember(_m_serviceId, _m_webId, _m_tribeId, _m_member, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_tribeId;
        const ::OpenImWebService::SWebUserInfo& _m_member;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__AddTribeMember_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribeId, member, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::DelTribeMember(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::std::string& operId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::std::string& operId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribeId(tribeId),
            _m_memberId(memberId),
            _m_operId(operId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->DelTribeMember(_m_serviceId, _m_webId, _m_tribeId, _m_memberId, _m_operId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_tribeId;
        const ::OpenImWebService::SWebUserInfo& _m_memberId;
        const ::std::string& _m_operId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__DelTribeMember_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribeId, memberId, operId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::QuitTribe(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& tribeId, const ::OpenImWebService::SWebUserInfo& memberId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_tribeId(tribeId),
            _m_memberId(memberId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->QuitTribe(_m_serviceId, _m_webId, _m_tribeId, _m_memberId, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_tribeId;
        const ::OpenImWebService::SWebUserInfo& _m_memberId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__QuitTribe_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, tribeId, memberId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::AddContact(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& wangwangId, const ::OpenImWebService::SWebUserInfoSeq& contactList, ::OpenImWebService::CntctSeq& cnt, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& wangwangId, const ::OpenImWebService::SWebUserInfoSeq& contactList, ::OpenImWebService::CntctSeq& cnt, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_wangwangId(wangwangId),
            _m_contactList(contactList),
            _m_cnt(cnt)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->AddContact(_m_serviceId, _m_webId, _m_wangwangId, _m_contactList, _m_cnt, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_wangwangId;
        const ::OpenImWebService::SWebUserInfoSeq& _m_contactList;
        ::OpenImWebService::CntctSeq& _m_cnt;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__AddContact_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, wangwangId, contactList, cnt, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::SendWebsiteMsg(const ::std::string& serviceId, const ::std::string& webId, const ::Ice::StringSeq& receivers, const ::OpenImWebService::SNotifySysMsg& message, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::Ice::StringSeq& receivers, const ::OpenImWebService::SNotifySysMsg& message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_receivers(receivers),
            _m_message(message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->SendWebsiteMsg(_m_serviceId, _m_webId, _m_receivers, _m_message, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::Ice::StringSeq& _m_receivers;
        const ::OpenImWebService::SNotifySysMsg& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__SendWebsiteMsg_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, receivers, message, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::SendUserMsg(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int cmdId, const ::std::string& fromId, const ::std::string& toId, const ::OpenImWebService::KVMap& message, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, ::Ice::Int cmdId, const ::std::string& fromId, const ::std::string& toId, const ::OpenImWebService::KVMap& message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_cmdId(cmdId),
            _m_fromId(fromId),
            _m_toId(toId),
            _m_message(message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->SendUserMsg(_m_serviceId, _m_webId, _m_cmdId, _m_fromId, _m_toId, _m_message, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        ::Ice::Int _m_cmdId;
        const ::std::string& _m_fromId;
        const ::std::string& _m_toId;
        const ::OpenImWebService::KVMap& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__SendUserMsg_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, cmdId, fromId, toId, message, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetHisOnline(const ::std::string& serviceId, const ::std::string& webId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_fromDate(fromDate),
            _m_toDate(toDate),
            _m_data(data)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetHisOnline(_m_serviceId, _m_webId, _m_fromDate, _m_toDate, _m_data, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        const ::std::string& _m_fromDate;
        const ::std::string& _m_toDate;
        ::OpenImWebService::SWebStatisticsSeq& _m_data;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetHisOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, fromDate, toDate, data, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetAllHisOnline(const ::std::string& serviceId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& fromDate, const ::std::string& toDate, ::OpenImWebService::SWebStatisticsSeq& data, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_fromDate(fromDate),
            _m_toDate(toDate),
            _m_data(data)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetAllHisOnline(_m_serviceId, _m_fromDate, _m_toDate, _m_data, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_fromDate;
        const ::std::string& _m_toDate;
        ::OpenImWebService::SWebStatisticsSeq& _m_data;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetAllHisOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, fromDate, toDate, data, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetCurrOnline(const ::std::string& serviceId, const ::std::string& webId, ::Ice::Long& number, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, ::Ice::Long& number, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_number(number)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetCurrOnline(_m_serviceId, _m_webId, _m_number, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        ::Ice::Long& _m_number;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetCurrOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, number, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetAllCurrOnline(const ::std::string& serviceId, ::Ice::Long& number, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, ::Ice::Long& number, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_number(number)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetAllCurrOnline(_m_serviceId, _m_number, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        ::Ice::Long& _m_number;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetAllCurrOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, number, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetHisMaxOnline(const ::std::string& serviceId, const ::std::string& webId, ::OpenImWebService::SWebStatistics& data, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, const ::std::string& webId, ::OpenImWebService::SWebStatistics& data, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_webId(webId),
            _m_data(data)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetHisMaxOnline(_m_serviceId, _m_webId, _m_data, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        const ::std::string& _m_webId;
        ::OpenImWebService::SWebStatistics& _m_data;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetHisMaxOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, webId, data, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::GetAllHisMaxOnline(const ::std::string& serviceId, ::std::string& date, ::Ice::Long& number, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& serviceId, ::std::string& date, ::Ice::Long& number, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_serviceId(serviceId),
            _m_date(date),
            _m_number(number)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->GetAllHisMaxOnline(_m_serviceId, _m_date, _m_number, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_serviceId;
        ::std::string& _m_date;
        ::Ice::Long& _m_number;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__GetAllHisMaxOnline_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, serviceId, date, number, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::OpenImWebService::OpenImSrvMgr::QueryLog(const ::OpenImWebService::QueryItems& qi, ::OpenImWebService::SUidPairMsgSeq& rl, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::OpenImWebService::QueryItems& qi, ::OpenImWebService::SUidPairMsgSeq& rl, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_qi(qi),
            _m_rl(rl)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::OpenImWebService::OpenImSrvMgr* servant = dynamic_cast< ::OpenImWebService::OpenImSrvMgr*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->QueryLog(_m_qi, _m_rl, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::OpenImWebService::QueryItems& _m_qi;
        ::OpenImWebService::SUidPairMsgSeq& _m_rl;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __OpenImWebService__OpenImSrvMgr__QueryLog_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, qi, rl, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::ObjectPtr
OpenImWebService::OpenImSrvMgr::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __OpenImWebService__OpenImSrvMgr_ids[2] =
{
    "::Ice::Object",
    "::OpenImWebService::OpenImSrvMgr"
};

bool
OpenImWebService::OpenImSrvMgr::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__OpenImWebService__OpenImSrvMgr_ids, __OpenImWebService__OpenImSrvMgr_ids + 2, _s);
}

::std::vector< ::std::string>
OpenImWebService::OpenImSrvMgr::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__OpenImWebService__OpenImSrvMgr_ids[0], &__OpenImWebService__OpenImSrvMgr_ids[2]);
}

const ::std::string&
OpenImWebService::OpenImSrvMgr::ice_id(const ::Ice::Current&) const
{
    return __OpenImWebService__OpenImSrvMgr_ids[1];
}

const ::std::string&
OpenImWebService::OpenImSrvMgr::ice_staticId()
{
    return __OpenImWebService__OpenImSrvMgr_ids[1];
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___BindService(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string webUid;
    ::std::string aliuid;
    ::std::string currToken;
    ::Ice::Long t;
    ::std::string wangwangId;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(webUid);
    __is->read(aliuid);
    __is->read(currToken);
    __is->read(t);
    __is->read(wangwangId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = BindService(serviceId, webId, webUid, aliuid, currToken, t, wangwangId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___UnbindService(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string webUid;
    ::std::string wangwangId;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(webUid);
    __is->read(wangwangId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = UnbindService(serviceId, webId, webUid, wangwangId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___DoAuth(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string aliuid;
    ::std::string token;
    ::Ice::Long t;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(aliuid);
    __is->read(token);
    __is->read(t);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string webUid;
    ::Ice::Int __ret = DoAuth(serviceId, webId, aliuid, token, t, webUid, __current);
    __os->write(webUid);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___AddWebsite(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string name;
    ::OpenImWebService::SUrlInfoSeq webUrl;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(name);
    ::OpenImWebService::__readSUrlInfoSeq(__is, webUrl);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = AddWebsite(serviceId, webId, name, webUrl, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___DelWebsite(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    __is->read(serviceId);
    __is->read(webId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = DelWebsite(serviceId, webId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___ChgWebsite(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string name;
    ::OpenImWebService::SUrlInfoSeq webUrl;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(name);
    ::OpenImWebService::__readSUrlInfoSeq(__is, webUrl);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = ChgWebsite(serviceId, webId, name, webUrl, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___ChgWebsiteStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::Ice::Int status;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(status);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = ChgWebsiteStatus(serviceId, webId, status, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___SyncWebTribe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::OpenImWebService::STribeInfo tribe;
    __is->read(serviceId);
    __is->read(webId);
    tribe.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long tribeId;
    ::Ice::Int __ret = SyncWebTribe(serviceId, webId, tribe, tribeId, __current);
    __os->write(tribeId);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___StopWebTribe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string tribeId;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(tribeId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = StopWebTribe(serviceId, webId, tribeId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___ModifyWebTribe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string tribeId;
    ::OpenImWebService::KVMap items;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(tribeId);
    ::OpenImWebService::__readKVMap(__is, items);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = ModifyWebTribe(serviceId, webId, tribeId, items, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___AddTribeMember(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string tribeId;
    ::OpenImWebService::SWebUserInfo member;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(tribeId);
    member.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = AddTribeMember(serviceId, webId, tribeId, member, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___DelTribeMember(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string tribeId;
    ::OpenImWebService::SWebUserInfo memberId;
    ::std::string operId;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(tribeId);
    memberId.__read(__is);
    __is->read(operId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = DelTribeMember(serviceId, webId, tribeId, memberId, operId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___QuitTribe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string tribeId;
    ::OpenImWebService::SWebUserInfo memberId;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(tribeId);
    memberId.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = QuitTribe(serviceId, webId, tribeId, memberId, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___AddContact(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string wangwangId;
    ::OpenImWebService::SWebUserInfoSeq contactList;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(wangwangId);
    ::OpenImWebService::__readSWebUserInfoSeq(__is, contactList);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OpenImWebService::CntctSeq cnt;
    ::Ice::Int __ret = AddContact(serviceId, webId, wangwangId, contactList, cnt, __current);
    if(cnt.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&cnt[0], &cnt[0] + cnt.size());
    }
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___SendWebsiteMsg(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::Ice::StringSeq receivers;
    ::OpenImWebService::SNotifySysMsg message;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(receivers);
    message.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = SendWebsiteMsg(serviceId, webId, receivers, message, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___SendUserMsg(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::Ice::Int cmdId;
    ::std::string fromId;
    ::std::string toId;
    ::OpenImWebService::KVMap message;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(cmdId);
    __is->read(fromId);
    __is->read(toId);
    ::OpenImWebService::__readKVMap(__is, message);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = SendUserMsg(serviceId, webId, cmdId, fromId, toId, message, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetHisOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    ::std::string fromDate;
    ::std::string toDate;
    __is->read(serviceId);
    __is->read(webId);
    __is->read(fromDate);
    __is->read(toDate);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OpenImWebService::SWebStatisticsSeq data;
    ::Ice::Int __ret = GetHisOnline(serviceId, webId, fromDate, toDate, data, __current);
    if(data.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::OpenImWebService::__writeSWebStatisticsSeq(__os, &data[0], &data[0] + data.size());
    }
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetAllHisOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string fromDate;
    ::std::string toDate;
    __is->read(serviceId);
    __is->read(fromDate);
    __is->read(toDate);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OpenImWebService::SWebStatisticsSeq data;
    ::Ice::Int __ret = GetAllHisOnline(serviceId, fromDate, toDate, data, __current);
    if(data.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::OpenImWebService::__writeSWebStatisticsSeq(__os, &data[0], &data[0] + data.size());
    }
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetCurrOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    __is->read(serviceId);
    __is->read(webId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long number;
    ::Ice::Int __ret = GetCurrOnline(serviceId, webId, number, __current);
    __os->write(number);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetAllCurrOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    __is->read(serviceId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Long number;
    ::Ice::Int __ret = GetAllCurrOnline(serviceId, number, __current);
    __os->write(number);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetHisMaxOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    ::std::string webId;
    __is->read(serviceId);
    __is->read(webId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OpenImWebService::SWebStatistics data;
    ::Ice::Int __ret = GetHisMaxOnline(serviceId, webId, data, __current);
    data.__write(__os);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___GetAllHisMaxOnline(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string serviceId;
    __is->read(serviceId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string date;
    ::Ice::Long number;
    ::Ice::Int __ret = GetAllHisMaxOnline(serviceId, date, number, __current);
    __os->write(date);
    __os->write(number);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::___QueryLog(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::OpenImWebService::QueryItems qi;
    qi.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::OpenImWebService::SUidPairMsgSeq rl;
    ::Ice::Int __ret = QueryLog(qi, rl, __current);
    if(rl.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::OpenImWebService::__writeSUidPairMsgSeq(__os, &rl[0], &rl[0] + rl.size());
    }
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

static ::std::string __OpenImWebService__OpenImSrvMgr_all[] =
{
    "AddContact",
    "AddTribeMember",
    "AddWebsite",
    "BindService",
    "ChgWebsite",
    "ChgWebsiteStatus",
    "DelTribeMember",
    "DelWebsite",
    "DoAuth",
    "GetAllCurrOnline",
    "GetAllHisMaxOnline",
    "GetAllHisOnline",
    "GetCurrOnline",
    "GetHisMaxOnline",
    "GetHisOnline",
    "ModifyWebTribe",
    "QueryLog",
    "QuitTribe",
    "SendUserMsg",
    "SendWebsiteMsg",
    "StopWebTribe",
    "SyncWebTribe",
    "UnbindService",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::Ice::DispatchStatus
OpenImWebService::OpenImSrvMgr::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__OpenImWebService__OpenImSrvMgr_all, __OpenImWebService__OpenImSrvMgr_all + 27, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __OpenImWebService__OpenImSrvMgr_all)
    {
        case 0:
        {
            return ___AddContact(in, current);
        }
        case 1:
        {
            return ___AddTribeMember(in, current);
        }
        case 2:
        {
            return ___AddWebsite(in, current);
        }
        case 3:
        {
            return ___BindService(in, current);
        }
        case 4:
        {
            return ___ChgWebsite(in, current);
        }
        case 5:
        {
            return ___ChgWebsiteStatus(in, current);
        }
        case 6:
        {
            return ___DelTribeMember(in, current);
        }
        case 7:
        {
            return ___DelWebsite(in, current);
        }
        case 8:
        {
            return ___DoAuth(in, current);
        }
        case 9:
        {
            return ___GetAllCurrOnline(in, current);
        }
        case 10:
        {
            return ___GetAllHisMaxOnline(in, current);
        }
        case 11:
        {
            return ___GetAllHisOnline(in, current);
        }
        case 12:
        {
            return ___GetCurrOnline(in, current);
        }
        case 13:
        {
            return ___GetHisMaxOnline(in, current);
        }
        case 14:
        {
            return ___GetHisOnline(in, current);
        }
        case 15:
        {
            return ___ModifyWebTribe(in, current);
        }
        case 16:
        {
            return ___QueryLog(in, current);
        }
        case 17:
        {
            return ___QuitTribe(in, current);
        }
        case 18:
        {
            return ___SendUserMsg(in, current);
        }
        case 19:
        {
            return ___SendWebsiteMsg(in, current);
        }
        case 20:
        {
            return ___StopWebTribe(in, current);
        }
        case 21:
        {
            return ___SyncWebTribe(in, current);
        }
        case 22:
        {
            return ___UnbindService(in, current);
        }
        case 23:
        {
            return ___ice_id(in, current);
        }
        case 24:
        {
            return ___ice_ids(in, current);
        }
        case 25:
        {
            return ___ice_isA(in, current);
        }
        case 26:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
OpenImWebService::OpenImSrvMgr::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
OpenImWebService::OpenImSrvMgr::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
OpenImWebService::OpenImSrvMgr::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OpenImWebService::OpenImSrvMgr was not generated with stream support";
    throw ex;
}

void
OpenImWebService::OpenImSrvMgr::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type OpenImWebService::OpenImSrvMgr was not generated with stream support";
    throw ex;
}
#endif

void 
OpenImWebService::__patch__OpenImSrvMgrPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::OpenImWebService::OpenImSrvMgrPtr* p = static_cast< ::OpenImWebService::OpenImSrvMgrPtr*>(__addr);
    assert(p);
    *p = ::OpenImWebService::OpenImSrvMgrPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::OpenImWebService::OpenImSrvMgr::ice_staticId(), v->ice_id());
    }
}
